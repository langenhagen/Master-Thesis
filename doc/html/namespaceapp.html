<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Unsupervised Detection of Salient Region in Image Databases: app Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Unsupervised Detection of Salient Region in Image Databases
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Crawling images in an image database, detecting salient objects and clustering the images accordingly</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceapp.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">app Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Solution namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceapp_1_1clusterer__type"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp_1_1clusterer__type.html">clusterer_type</a></td></tr>
<tr class="memdesc:namespaceapp_1_1clusterer__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible clusterer types wrapping namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceapp_1_1detector__type"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp_1_1detector__type.html">detector_type</a></td></tr>
<tr class="memdesc:namespaceapp_1_1detector__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible feature extractor types wrapping namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceapp_1_1evaluation__mode"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp_1_1evaluation__mode.html">evaluation_mode</a></td></tr>
<tr class="memdesc:namespaceapp_1_1evaluation__mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible evaluation modes wrapping namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceapp_1_1extractor__type"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp_1_1extractor__type.html">extractor_type</a></td></tr>
<tr class="memdesc:namespaceapp_1_1extractor__type"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceapp_1_1extractor__type.html" title="extractor_type enumeration wrapping namespace. ">extractor_type</a> enumeration wrapping namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceapp_1_1input__request"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp_1_1input__request.html">input_request</a></td></tr>
<tr class="memdesc:namespaceapp_1_1input__request"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceapp_1_1input__request.html" title="input_request enumeration wrapping namespace. ">input_request</a> enumeration wrapping namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceapp_1_1_r_e_t_u_r_n___c_o_d_e"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp_1_1_r_e_t_u_r_n___c_o_d_e.html">RETURN_CODE</a></td></tr>
<tr class="memdesc:namespaceapp_1_1_r_e_t_u_r_n___c_o_d_e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Several return error codes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceapp_1_1return__error__code"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp_1_1return__error__code.html">return_error_code</a></td></tr>
<tr class="memdesc:namespaceapp_1_1return__error__code"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceapp_1_1return__error__code.html" title="return_error_code enumeration wrapping namespace. ">return_error_code</a> enumeration wrapping namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapp_1_1_clusterer.html">Clusterer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for clusterer classes.  <a href="classapp_1_1_clusterer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapp_1_1clusterer__description.html">clusterer_description</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the clusterer attributes.  <a href="structapp_1_1clusterer__description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapp_1_1_contour_extractor.html">ContourExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classapp_1_1_contour_extractor.html" title="ContourExtractor uses fourier descriptors to describe shape. ">ContourExtractor</a> uses fourier descriptors to describe shape.  <a href="classapp_1_1_contour_extractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapp_1_1_contour_histogram_extractor.html">ContourHistogramExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combined shape and color histogram descriptor. Feature extractor uses a <a class="el" href="classapp_1_1_contour_extractor.html" title="ContourExtractor uses fourier descriptors to describe shape. ">ContourExtractor</a> and a <a class="el" href="classapp_1_1_histogram_extractor.html" title="Feature Extractor that generates HSV histograms as feature vectors. ">HistogramExtractor</a> and aggregates them.  <a href="classapp_1_1_contour_histogram_extractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapp_1_1feature__extractor__description.html">feature_extractor_description</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the feature extractor factory attributes.  <a href="structapp_1_1feature__extractor__description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapp_1_1_feature_extractor.html">FeatureExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for all feature extractors.  <a href="classapp_1_1_feature_extractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapp_1_1_gaussian.html">Gaussian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A templated (one-dimensional) gaussian distribution density function.  <a href="classapp_1_1_gaussian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapp_1_1global__stats.html">global_stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds global statistics of the processing chain.  <a href="structapp_1_1global__stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapp_1_1_histogram_extractor.html">HistogramExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Feature Extractor that generates HSV histograms as feature vectors.  <a href="classapp_1_1_histogram_extractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapp_1_1_image_processor.html">ImageProcessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the whole stuff needed for processing an image. It chooses the appropriate saliency detector and feature extractor and contains the processing chain within one function call. It also handles the writing of intermediate results to disk. The object maintains (1) The saliency map generator. (2) Creates salient object <a class="el" href="classapp_1_1_feature_extractor.html" title="Interface for all feature extractors. ">FeatureExtractor</a>.  <a href="classapp_1_1_image_processor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapp_1_1_k_means_clusterer.html">KMeansClusterer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">KMeans clusterer Uses opencv flann hierarchical k means.  <a href="classapp_1_1_k_means_clusterer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapp_1_1_o_p_t_i_c_s_clusterer.html">OPTICSClusterer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">OPTCIS clusterer. Density based clustering.  <a href="classapp_1_1_o_p_t_i_c_s_clusterer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapp_1_1_outlier_clusterer.html">OutlierClusterer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outlier clusterer. Finds orphanized elements.  <a href="classapp_1_1_outlier_clusterer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapp_1_1program__options.html">program_options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hold global program configurations. Holds the global program attributes and the descriptions of the application's modules.  <a href="structapp_1_1program__options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapp_1_1saliency__detector__description.html">saliency_detector_description</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the attributes for the saliency detector.  <a href="structapp_1_1saliency__detector__description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapp_1_1_saliency_detector.html">SaliencyDetector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_saliency.html">Saliency</a> detector interface.  <a href="classapp_1_1_saliency_detector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapp_1_1_saliency_filters.html">SaliencyFilters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the <a class="el" href="classapp_1_1_saliency_detector.html" title="Saliency detector interface. ">SaliencyDetector</a> interface. Implements <a class="el" href="class_saliency.html">Saliency</a> Filters algorithm by Philipp Kraehenbuehl et al..  <a href="classapp_1_1_saliency_filters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a983f01fad4505cd5a1cb15e09124f47f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a983f01fad4505cd5a1cb15e09124f47f"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a983f01fad4505cd5a1cb15e09124f47f">uint</a></td></tr>
<tr class="memdesc:a983f01fad4505cd5a1cb15e09124f47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned int. <br /></td></tr>
<tr class="separator:a983f01fad4505cd5a1cb15e09124f47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75415fe5b5101d4e65192fbd51f9b19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac75415fe5b5101d4e65192fbd51f9b19"></a>
typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#ac75415fe5b5101d4e65192fbd51f9b19">real</a></td></tr>
<tr class="memdesc:ac75415fe5b5101d4e65192fbd51f9b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">The floating point value. Change at will. <br /></td></tr>
<tr class="separator:ac75415fe5b5101d4e65192fbd51f9b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b4327996fcb618f612ae84a7377379"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41b4327996fcb618f612ae84a7377379"></a>
typedef boost::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a41b4327996fcb618f612ae84a7377379">timespan</a></td></tr>
<tr class="memdesc:a41b4327996fcb618f612ae84a7377379"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time granularity to which to round performance counters. Change at will. <br /></td></tr>
<tr class="separator:a41b4327996fcb618f612ae84a7377379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0c9a79c3637d26d5e26bbb747d6f14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a0c9a79c3637d26d5e26bbb747d6f14"></a>
typedef std::vector&lt; <a class="el" href="namespaceapp.html#ac75415fe5b5101d4e65192fbd51f9b19">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a5a0c9a79c3637d26d5e26bbb747d6f14">Vec1r</a></td></tr>
<tr class="memdesc:a5a0c9a79c3637d26d5e26bbb747d6f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of real-values. <br /></td></tr>
<tr class="separator:a5a0c9a79c3637d26d5e26bbb747d6f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ca45a6a9a4da2d3683eac6e49bafa9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4ca45a6a9a4da2d3683eac6e49bafa9"></a>
typedef std::vector&lt; <a class="el" href="namespaceapp.html#a983f01fad4505cd5a1cb15e09124f47f">uint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#ae4ca45a6a9a4da2d3683eac6e49bafa9">Vec1UInt</a></td></tr>
<tr class="memdesc:ae4ca45a6a9a4da2d3683eac6e49bafa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of unsigned integer values. <br /></td></tr>
<tr class="separator:ae4ca45a6a9a4da2d3683eac6e49bafa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3319102c6074cf269901c360d08b725"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3319102c6074cf269901c360d08b725"></a>
typedef std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#ad3319102c6074cf269901c360d08b725">Vec1i</a></td></tr>
<tr class="memdesc:ad3319102c6074cf269901c360d08b725"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of integer values. <br /></td></tr>
<tr class="separator:ad3319102c6074cf269901c360d08b725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ce3a284714251ea49d263916b033b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77ce3a284714251ea49d263916b033b1"></a>
typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a77ce3a284714251ea49d263916b033b1">Vec1str</a></td></tr>
<tr class="memdesc:a77ce3a284714251ea49d263916b033b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of strings. <br /></td></tr>
<tr class="separator:a77ce3a284714251ea49d263916b033b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bd809a7a3b796566ed6023b105e46d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7bd809a7a3b796566ed6023b105e46d"></a>
typedef cv::Mat_&lt; <a class="el" href="namespaceapp.html#ac75415fe5b5101d4e65192fbd51f9b19">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#aa7bd809a7a3b796566ed6023b105e46d">Mat1r</a></td></tr>
<tr class="memdesc:aa7bd809a7a3b796566ed6023b105e46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single channel real valued matrix. Not to be confused with Mat1f or Mat1d! <br /></td></tr>
<tr class="separator:aa7bd809a7a3b796566ed6023b105e46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf50b26ad77764581d2e32d02afdce0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecf50b26ad77764581d2e32d02afdce0"></a>
typedef cv::Mat_&lt; cv::Vec&lt; <a class="el" href="namespaceapp.html#ac75415fe5b5101d4e65192fbd51f9b19">real</a>, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#aecf50b26ad77764581d2e32d02afdce0">Mat2r</a></td></tr>
<tr class="memdesc:aecf50b26ad77764581d2e32d02afdce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A two-channel real valued matrix. Not to be confused with Mat2f or Mat2d! <br /></td></tr>
<tr class="separator:aecf50b26ad77764581d2e32d02afdce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cba2b240459a595b5c6f820e9dcfd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4cba2b240459a595b5c6f820e9dcfd4"></a>
typedef cv::Mat_&lt; cv::Vec&lt; <a class="el" href="namespaceapp.html#ac75415fe5b5101d4e65192fbd51f9b19">real</a>, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#ad4cba2b240459a595b5c6f820e9dcfd4">Mat3r</a></td></tr>
<tr class="memdesc:ad4cba2b240459a595b5c6f820e9dcfd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3 channel real value matrix. <br /></td></tr>
<tr class="separator:ad4cba2b240459a595b5c6f820e9dcfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2e791024213cccec257f42a43eae8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c2e791024213cccec257f42a43eae8e"></a>
typedef cv::Point_&lt; <a class="el" href="namespaceapp.html#ac75415fe5b5101d4e65192fbd51f9b19">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a8c2e791024213cccec257f42a43eae8e">Point2r</a></td></tr>
<tr class="memdesc:a8c2e791024213cccec257f42a43eae8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">2d real valued Point. <br /></td></tr>
<tr class="separator:a8c2e791024213cccec257f42a43eae8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e5f30d34dbdaaf73b3e3004a344773"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2e5f30d34dbdaaf73b3e3004a344773"></a>
typedef std::vector&lt; cv::Point2i &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#ac2e5f30d34dbdaaf73b3e3004a344773">Contour</a></td></tr>
<tr class="memdesc:ac2e5f30d34dbdaaf73b3e3004a344773"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opencv contour. <br /></td></tr>
<tr class="separator:ac2e5f30d34dbdaaf73b3e3004a344773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c9055f6f791fe7dbb9e67e6eb9e005"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7c9055f6f791fe7dbb9e67e6eb9e005"></a>
typedef std::unordered_set&lt; <a class="el" href="namespaceapp.html#a983f01fad4505cd5a1cb15e09124f47f">uint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#ad7c9055f6f791fe7dbb9e67e6eb9e005">UIntSet</a></td></tr>
<tr class="memdesc:ad7c9055f6f791fe7dbb9e67e6eb9e005"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of unsigned integers. <br /></td></tr>
<tr class="separator:ad7c9055f6f791fe7dbb9e67e6eb9e005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ceeae09ee0bd6a55f6fefdf1814187e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ceeae09ee0bd6a55f6fefdf1814187e"></a>
typedef <a class="el" href="classapp_1_1_gaussian.html">Gaussian</a>&lt; <a class="el" href="namespaceapp.html#ac75415fe5b5101d4e65192fbd51f9b19">app::real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a3ceeae09ee0bd6a55f6fefdf1814187e">RealGaussian</a></td></tr>
<tr class="memdesc:a3ceeae09ee0bd6a55f6fefdf1814187e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real valued gaussian density function. <br /></td></tr>
<tr class="separator:a3ceeae09ee0bd6a55f6fefdf1814187e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032b65c802c303d96e4302c12567afdf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a032b65c802c303d96e4302c12567afdf"></a>
typedef std::tuple&lt; string, <a class="el" href="namespaceapp.html#a983f01fad4505cd5a1cb15e09124f47f">uint</a>, <a class="el" href="namespaceapp.html#a983f01fad4505cd5a1cb15e09124f47f">uint</a>, <a class="el" href="namespaceapp.html#a983f01fad4505cd5a1cb15e09124f47f">uint</a>, <a class="el" href="namespaceapp.html#ac75415fe5b5101d4e65192fbd51f9b19">real</a>, <a class="el" href="namespaceapp.html#ac75415fe5b5101d4e65192fbd51f9b19">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a032b65c802c303d96e4302c12567afdf">cluster_info_t</a></td></tr>
<tr class="memdesc:a032b65c802c303d96e4302c12567afdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple of assigned class name, true, positives, false positives and false negatives. <br /></td></tr>
<tr class="separator:a032b65c802c303d96e4302c12567afdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a85261fc6195c35ee47c4c5d835b11c29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a85261fc6195c35ee47c4c5d835b11c29">nb_getch</a> ()</td></tr>
<tr class="separator:a85261fc6195c35ee47c4c5d835b11c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2c3881de7b652e1c91e3e8d5bef365"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#aea2c3881de7b652e1c91e3e8d5bef365">exit_if_false</a> (bool result, int on_exit_result=RETURN_CODE::UNDEFINED_ERROR)</td></tr>
<tr class="separator:aea2c3881de7b652e1c91e3e8d5bef365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7586a2410527f8d7c03d51f23f2ccd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#ad7586a2410527f8d7c03d51f23f2ccd4">on_open_file_error</a> (const std::string &amp;fname)</td></tr>
<tr class="separator:ad7586a2410527f8d7c03d51f23f2ccd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdd1fc00a81bb4f09df8d3c3424ef91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a3bdd1fc00a81bb4f09df8d3c3424ef91">on_read_file_error</a> (const std::string &amp;fname, unsigned int line)</td></tr>
<tr class="separator:a3bdd1fc00a81bb4f09df8d3c3424ef91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2769ea9a48be6aaa6b5233f5a8d2af6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#ab2769ea9a48be6aaa6b5233f5a8d2af6">on_delete_file_contents_error</a> (const std::string &amp;fname)</td></tr>
<tr class="separator:ab2769ea9a48be6aaa6b5233f5a8d2af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8b1690715c26806eaad3acc95652d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a8e8b1690715c26806eaad3acc95652d7">on_write_file_error</a> (const std::string &amp;fname)</td></tr>
<tr class="separator:a8e8b1690715c26806eaad3acc95652d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2c8a6555524e3288729a357ed1dd54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#abc2c8a6555524e3288729a357ed1dd54">on_filesystem_exception</a> (boost::filesystem::filesystem_error &amp;e)</td></tr>
<tr class="separator:abc2c8a6555524e3288729a357ed1dd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4031cbaf44adbc539d4825c261ca02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#acc4031cbaf44adbc539d4825c261ca02">on_invalid_mat</a> (const std::string &amp;fname, const int line)</td></tr>
<tr class="separator:acc4031cbaf44adbc539d4825c261ca02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5578e1cb32a5b7d2240ee0fa364a983b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a5578e1cb32a5b7d2240ee0fa364a983b">for_each_file_in_direcory_tree</a> (boost::filesystem::path &amp;p, std::function&lt; bool(boost::filesystem::directory_entry &amp;, <a class="el" href="namespaceapp.html#a983f01fad4505cd5a1cb15e09124f47f">uint</a> level)&gt; callback, std::function&lt; void(boost::filesystem::filesystem_error &amp;)&gt; exception_callback=<a class="el" href="namespaceapp.html#abc2c8a6555524e3288729a357ed1dd54">on_filesystem_exception</a>, int max_level=-1)</td></tr>
<tr class="separator:a5578e1cb32a5b7d2240ee0fa364a983b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41fd06c840b462a7867f27836b3e47c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#ac41fd06c840b462a7867f27836b3e47c">getlines_from_file</a> (const std::string &amp;fname, std::function&lt; void(std::string &amp;, unsigned int)&gt; callback, std::function&lt; void(const std::string &amp;)&gt; error_open_callback=<a class="el" href="namespaceapp.html#ad7586a2410527f8d7c03d51f23f2ccd4">on_open_file_error</a>, std::function&lt; void(const std::string &amp;, unsigned int)&gt; error_read_callback=<a class="el" href="namespaceapp.html#a3bdd1fc00a81bb4f09df8d3c3424ef91">on_read_file_error</a>)</td></tr>
<tr class="separator:ac41fd06c840b462a7867f27836b3e47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159b1b383e66f23254b88ece2f9b97e0"><td class="memTemplParams" colspan="2">template&lt;typename F , template&lt; class T, class=std::allocator&lt; T &gt; &gt; class container_type&gt; </td></tr>
<tr class="memitem:a159b1b383e66f23254b88ece2f9b97e0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a159b1b383e66f23254b88ece2f9b97e0">to_file</a> (const std::string &amp;fname, const container_type&lt; F &gt; &amp;container, const std::string &amp;delimeter=&quot;\n&quot;, std::function&lt; void(const std::string &amp;) &gt; error_open_callback=<a class="el" href="namespaceapp.html#ad7586a2410527f8d7c03d51f23f2ccd4">on_open_file_error</a>, std::function&lt; void(const std::string &amp;) &gt; error_write_callback=<a class="el" href="namespaceapp.html#a8e8b1690715c26806eaad3acc95652d7">on_write_file_error</a>)</td></tr>
<tr class="separator:a159b1b383e66f23254b88ece2f9b97e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8762b23bd248bc58b2a9a0c6c6bc5238"><td class="memTemplParams" colspan="2">template&lt;class mat_type &gt; </td></tr>
<tr class="memitem:a8762b23bd248bc58b2a9a0c6c6bc5238"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a8762b23bd248bc58b2a9a0c6c6bc5238">to_file</a> (const std::string &amp;fname, const mat_type &amp;mat, const std::string &amp;row_delimeter=&quot;\n&quot;, const std::string &amp;col_delimeter=&quot; &quot;, std::function&lt; void(const std::string &amp;) &gt; error_open_callback=<a class="el" href="namespaceapp.html#ad7586a2410527f8d7c03d51f23f2ccd4">on_open_file_error</a>, std::function&lt; void(const std::string &amp;) &gt; error_write_callback=<a class="el" href="namespaceapp.html#a8e8b1690715c26806eaad3acc95652d7">on_write_file_error</a>)</td></tr>
<tr class="separator:a8762b23bd248bc58b2a9a0c6c6bc5238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff2e6a4f8dbb21e5967bd4a9d1902aa"><td class="memTemplParams" colspan="2">template&lt;template&lt; class T, class=std::allocator&lt; T &gt; &gt; class container_type&gt; </td></tr>
<tr class="memitem:abff2e6a4f8dbb21e5967bd4a9d1902aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapp.html#abff2e6a4f8dbb21e5967bd4a9d1902aa">from_file</a> (const std::string &amp;fname, container_type&lt; std::string &gt; &amp;out_container, std::function&lt; void(const std::string &amp;)&gt; error_open_callback=<a class="el" href="namespaceapp.html#ad7586a2410527f8d7c03d51f23f2ccd4">on_open_file_error</a>, std::function&lt; void(const std::string &amp;, unsigned int)&gt; error_read_callback=<a class="el" href="namespaceapp.html#a3bdd1fc00a81bb4f09df8d3c3424ef91">on_read_file_error</a>)</td></tr>
<tr class="separator:abff2e6a4f8dbb21e5967bd4a9d1902aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7b31e6b48e4bf41193cfa350c1fca5"><td class="memTemplParams" colspan="2">template&lt;typename F , template&lt; class T, class=std::allocator&lt; T &gt; &gt; class container_type&gt; </td></tr>
<tr class="memitem:a7d7b31e6b48e4bf41193cfa350c1fca5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a7d7b31e6b48e4bf41193cfa350c1fca5">from_file</a> (const std::string &amp;fname, container_type&lt; F &gt; &amp;out_container, std::function&lt; void(const std::string &amp;)&gt; error_open_callback=<a class="el" href="namespaceapp.html#ad7586a2410527f8d7c03d51f23f2ccd4">on_open_file_error</a>, std::function&lt; void(const std::string &amp;, unsigned int)&gt; error_read_callback=<a class="el" href="namespaceapp.html#a3bdd1fc00a81bb4f09df8d3c3424ef91">on_read_file_error</a>)</td></tr>
<tr class="separator:a7d7b31e6b48e4bf41193cfa350c1fca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93c0f0c765a05b18846a72d3364bc7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#ac93c0f0c765a05b18846a72d3364bc7e">delete_file_contents</a> (std::string &amp;fname, std::function&lt; void(const std::string &amp;)&gt; error_callback=<a class="el" href="namespaceapp.html#ab2769ea9a48be6aaa6b5233f5a8d2af6">on_delete_file_contents_error</a>)</td></tr>
<tr class="separator:ac93c0f0c765a05b18846a72d3364bc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f52b3408f946f2a5c42f45f7b62256d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a1f52b3408f946f2a5c42f45f7b62256d">create_directories</a> (const boost::filesystem::path &amp;p)</td></tr>
<tr class="separator:a1f52b3408f946f2a5c42f45f7b62256d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43eac5f357b8c07e316ac173d6ed99ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a43eac5f357b8c07e316ac173d6ed99ba">remove_path</a> (const boost::filesystem::path &amp;p)</td></tr>
<tr class="separator:a43eac5f357b8c07e316ac173d6ed99ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3516395d9bd8945f4bc7f44bc22bce26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a3516395d9bd8945f4bc7f44bc22bce26">symlink</a> (const boost::filesystem::path &amp;original_path, const boost::filesystem::path &amp;symlink_path)</td></tr>
<tr class="separator:a3516395d9bd8945f4bc7f44bc22bce26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b7e46dce9eccf90ca714b444221c13"><td class="memTemplParams" colspan="2">template&lt;typename F , template&lt; class T, class=std::allocator&lt; T &gt; &gt; class container_type&gt; </td></tr>
<tr class="memitem:ab0b7e46dce9eccf90ca714b444221c13"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapp.html#ab0b7e46dce9eccf90ca714b444221c13">to_string</a> (container_type&lt; F &gt; container, const char *delimeter=&quot;; &quot;)</td></tr>
<tr class="separator:ab0b7e46dce9eccf90ca714b444221c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3613a674a30654439fd46e39d4a8f22e"><td class="memTemplParams" colspan="2">template&lt;typename F , template&lt; class T, class=std::allocator&lt; T &gt; &gt; class container_type&gt; </td></tr>
<tr class="memitem:a3613a674a30654439fd46e39d4a8f22e"><td class="memTemplItemLeft" align="right" valign="top">container_type&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a3613a674a30654439fd46e39d4a8f22e">from_stream</a> (std::istream &amp;in_stream)</td></tr>
<tr class="separator:a3613a674a30654439fd46e39d4a8f22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa022e64add8ebff29719e167ce24bd7f"><td class="memTemplParams" colspan="2">template&lt;typename F , template&lt; class T, class=std::allocator&lt; T &gt; &gt; class container_type&gt; </td></tr>
<tr class="memitem:aa022e64add8ebff29719e167ce24bd7f"><td class="memTemplItemLeft" align="right" valign="top">container_type&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapp.html#aa022e64add8ebff29719e167ce24bd7f">from_string</a> (const std::string &amp;str)</td></tr>
<tr class="separator:aa022e64add8ebff29719e167ce24bd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841ba5877e0efc1a2918f24e5acb3479"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a841ba5877e0efc1a2918f24e5acb3479"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a841ba5877e0efc1a2918f24e5acb3479">from_file</a> (const std::string &amp;fname, cv::Mat_&lt; T &gt; &amp;out_mat, std::function&lt; void(const std::string &amp;, const int line) &gt; error_invalid_mat_callback=<a class="el" href="namespaceapp.html#acc4031cbaf44adbc539d4825c261ca02">on_invalid_mat</a>)</td></tr>
<tr class="separator:a841ba5877e0efc1a2918f24e5acb3479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c7014015b1485993355cb2d15a4bc0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a58c7014015b1485993355cb2d15a4bc0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a58c7014015b1485993355cb2d15a4bc0">operator&lt;&lt;</a> (std::ostream &amp;os, const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a58c7014015b1485993355cb2d15a4bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec26344c595ee9dcffc24abf83e5b7b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#afec26344c595ee9dcffc24abf83e5b7b">yes_no</a> (bool b)</td></tr>
<tr class="separator:afec26344c595ee9dcffc24abf83e5b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6900ebadff0147fabc161a10e16d2de2"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a6900ebadff0147fabc161a10e16d2de2">to_lower</a> (std::string &amp;s)</td></tr>
<tr class="separator:a6900ebadff0147fabc161a10e16d2de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5b2fbaa6faa41b0dffa39f410f002c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#ada5b2fbaa6faa41b0dffa39f410f002c">to_lower</a> (const std::string &amp;s)</td></tr>
<tr class="separator:ada5b2fbaa6faa41b0dffa39f410f002c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e2a618f7561a4909b1afdfd2e763ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a69e2a618f7561a4909b1afdfd2e763ad">get_mat_type</a> (int number)</td></tr>
<tr class="separator:a69e2a618f7561a4909b1afdfd2e763ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55324dccec02bb8125981faaf8ea479a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a55324dccec02bb8125981faaf8ea479a">wrap</a> (double val, double upper_limit=360)</td></tr>
<tr class="separator:a55324dccec02bb8125981faaf8ea479a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95da69cbba3f625c28cb5d0d3f5ec73"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#ab95da69cbba3f625c28cb5d0d3f5ec73">angle_diff</a> (double angle1, double angle2)</td></tr>
<tr class="separator:ab95da69cbba3f625c28cb5d0d3f5ec73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a78a30cf43e30263e71a29fddd7867"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a76a78a30cf43e30263e71a29fddd7867">parent</a> (std::vector&lt; cv::Vec4i &gt; hierarchy, int contour_index)</td></tr>
<tr class="separator:a76a78a30cf43e30263e71a29fddd7867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4212642aa23497c58e13d8c4fe8d7c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e4212642aa23497c58e13d8c4fe8d7c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a2e4212642aa23497c58e13d8c4fe8d7c">resize_interpolated</a> (const std::vector&lt; T &gt; &amp;v, <a class="el" href="namespaceapp.html#a983f01fad4505cd5a1cb15e09124f47f">uint</a> new_size)</td></tr>
<tr class="separator:a2e4212642aa23497c58e13d8c4fe8d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540822ab461eed15893a9c71ed1b9352"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a540822ab461eed15893a9c71ed1b9352"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a540822ab461eed15893a9c71ed1b9352">circular_cross_correlation_series</a> (const std::vector&lt; R &gt; &amp;a, const std::vector&lt; R &gt; &amp;b)</td></tr>
<tr class="separator:a540822ab461eed15893a9c71ed1b9352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd1d8cc33696148cdc5782472288107"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R &gt; </td></tr>
<tr class="memitem:a9fd1d8cc33696148cdc5782472288107"><td class="memTemplItemLeft" align="right" valign="top">cv::Point_&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a9fd1d8cc33696148cdc5782472288107">center</a> (const std::vector&lt; cv::Point_&lt; T &gt;&gt; &amp;v)</td></tr>
<tr class="separator:a9fd1d8cc33696148cdc5782472288107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62caaad5d84f1cbd2f91c8134e26b162"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62caaad5d84f1cbd2f91c8134e26b162"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a62caaad5d84f1cbd2f91c8134e26b162">is_inf</a> (const T &amp;v)</td></tr>
<tr class="separator:a62caaad5d84f1cbd2f91c8134e26b162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ca251579d3eaef879a0fa98ec363e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69ca251579d3eaef879a0fa98ec363e4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a69ca251579d3eaef879a0fa98ec363e4">is_nan</a> (const T &amp;v)</td></tr>
<tr class="separator:a69ca251579d3eaef879a0fa98ec363e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad572389c14e2c9526f91ae8131459322"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad572389c14e2c9526f91ae8131459322"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapp.html#ad572389c14e2c9526f91ae8131459322">is_valid</a> (const T &amp;v)</td></tr>
<tr class="separator:ad572389c14e2c9526f91ae8131459322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b21c7e02a9fd6bdbb694d9f78581e94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b21c7e02a9fd6bdbb694d9f78581e94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a7b21c7e02a9fd6bdbb694d9f78581e94">check_validity</a> (const T &amp;v, const std::string &amp;alias, const char *file, const int line)</td></tr>
<tr class="separator:a7b21c7e02a9fd6bdbb694d9f78581e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337440dd24613eeebf2395351e1e6bbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a337440dd24613eeebf2395351e1e6bbd">is_image_filetype_supported</a> (const string &amp;extension)</td></tr>
<tr class="separator:a337440dd24613eeebf2395351e1e6bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1012f9b751c47c096f29a62a55a5ef8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a1012f9b751c47c096f29a62a55a5ef8c">log_keyboard_commands</a> ()</td></tr>
<tr class="separator:a1012f9b751c47c096f29a62a55a5ef8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da989da51dae7767fa1bf82172a2e36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceapp_1_1input__request.html#aea4d1c47249b0959e3ff44c3b60cc7df">input_request::input_request</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a2da989da51dae7767fa1bf82172a2e36">get_keyboard_input</a> ()</td></tr>
<tr class="separator:a2da989da51dae7767fa1bf82172a2e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4964871026470eaf16e3f91ef43bb08d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceapp_1_1detector__type.html#ac35b8ea91b19cc3c40be2c20f7d0bfce">detector_type::detector_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a4964871026470eaf16e3f91ef43bb08d">detector_type_from_string</a> (string &amp;type)</td></tr>
<tr class="separator:a4964871026470eaf16e3f91ef43bb08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af478427ee0a08e8a59c872c1dee8e0c2"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#af478427ee0a08e8a59c872c1dee8e0c2">detector_types_string</a> ()</td></tr>
<tr class="separator:af478427ee0a08e8a59c872c1dee8e0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91547e5cba73d45c1e1ed7489d8563d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a91547e5cba73d45c1e1ed7489d8563d2">log_detector_types</a> ()</td></tr>
<tr class="separator:a91547e5cba73d45c1e1ed7489d8563d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac752c6012ea92ef9cbc85c40a08624e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceapp_1_1extractor__type.html#af7300cd9b95601f160223029cde889cf">extractor_type::extractor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#ac752c6012ea92ef9cbc85c40a08624e6">extractor_from_string</a> (string &amp;type)</td></tr>
<tr class="separator:ac752c6012ea92ef9cbc85c40a08624e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f4b75fa49d2c76dd33d1e84bbf7b54"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#ad7f4b75fa49d2c76dd33d1e84bbf7b54">extractor_types_string</a> ()</td></tr>
<tr class="memdesc:ad7f4b75fa49d2c76dd33d1e84bbf7b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string with the names of the supported feature extractor types.  <a href="#ad7f4b75fa49d2c76dd33d1e84bbf7b54">More...</a><br /></td></tr>
<tr class="separator:ad7f4b75fa49d2c76dd33d1e84bbf7b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ef84d2918527f8afda3f7e505d2d92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6ef84d2918527f8afda3f7e505d2d92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#ac6ef84d2918527f8afda3f7e505d2d92">log_extractor_types</a> ()</td></tr>
<tr class="memdesc:ac6ef84d2918527f8afda3f7e505d2d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs the feature extractor types for information purposes. <br /></td></tr>
<tr class="separator:ac6ef84d2918527f8afda3f7e505d2d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939e1a71674bdad3743a4b4da97d4acc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a939e1a71674bdad3743a4b4da97d4acc">log</a> (const <a class="el" href="structapp_1_1global__stats.html">global_stats</a> &amp;stats)</td></tr>
<tr class="separator:a939e1a71674bdad3743a4b4da97d4acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6fdddafe8b628f1c7ffa1adbb07baa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a6f6fdddafe8b628f1c7ffa1adbb07baa">log_program_options</a> (const <a class="el" href="structapp_1_1program__options.html">program_options</a> &amp;p)</td></tr>
<tr class="separator:a6f6fdddafe8b628f1c7ffa1adbb07baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276268e81e87e71f189fac56c0d6703b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a276268e81e87e71f189fac56c0d6703b">print_help_message</a> (const int args,...)</td></tr>
<tr class="separator:a276268e81e87e71f189fac56c0d6703b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0360326f32265761abc08c57a112ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#afd0360326f32265761abc08c57a112ba">adjust_program_options</a> (<a class="el" href="structapp_1_1program__options.html">program_options</a> &amp;p)</td></tr>
<tr class="separator:afd0360326f32265761abc08c57a112ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c57a163d1c2e36e9ecb9f5e42ac5b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a41c57a163d1c2e36e9ecb9f5e42ac5b3">init_program_options</a> (const int argc, const char *argv[], <a class="el" href="structapp_1_1program__options.html">program_options</a> &amp;p)</td></tr>
<tr class="separator:a41c57a163d1c2e36e9ecb9f5e42ac5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ad8be76358e3eb86c1ef52cf961213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceapp_1_1clusterer__type.html#a9d3883709cb4732512195c6ed005bc91">clusterer_type::clusterer_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a57ad8be76358e3eb86c1ef52cf961213">clusterer_type_from_string</a> (string &amp;type)</td></tr>
<tr class="separator:a57ad8be76358e3eb86c1ef52cf961213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d284e9cd54eda48d8b3e769c5d0f17"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a78d284e9cd54eda48d8b3e769c5d0f17">clusterer_types_string</a> ()</td></tr>
<tr class="separator:a78d284e9cd54eda48d8b3e769c5d0f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1606407671f1d1f26e7fadd644ffbdfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a1606407671f1d1f26e7fadd644ffbdfd">log_clusterer_types</a> ()</td></tr>
<tr class="separator:a1606407671f1d1f26e7fadd644ffbdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80972fc94aa415b0a860cdcafd65367e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a80972fc94aa415b0a860cdcafd65367e">eval_bayes</a> (const <a class="el" href="structapp_1_1program__options.html">program_options</a> &amp;params)</td></tr>
<tr class="separator:a80972fc94aa415b0a860cdcafd65367e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98de1bb3c1d7269c714e0e9b09490574"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceapp.html#ae4ca45a6a9a4da2d3683eac6e49bafa9">Vec1UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a98de1bb3c1d7269c714e0e9b09490574">assign_membership</a> (const <a class="el" href="namespaceapp.html#aa7bd809a7a3b796566ed6023b105e46d">Mat1r</a> &amp;probabilities)</td></tr>
<tr class="separator:a98de1bb3c1d7269c714e0e9b09490574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb41bcb728aae7f4d5d564d0ac4b5332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceapp_1_1evaluation__mode.html#a36fbac5d5f1bb29ef6d5e31b898ff0c4">evaluation_mode::evaluation_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#adb41bcb728aae7f4d5d564d0ac4b5332">evaluation_mode_from_string</a> (string &amp;type)</td></tr>
<tr class="separator:adb41bcb728aae7f4d5d564d0ac4b5332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcdec6e88d26cddff18231ff70f8f05"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a9bcdec6e88d26cddff18231ff70f8f05">evaluation_modes_string</a> ()</td></tr>
<tr class="separator:a9bcdec6e88d26cddff18231ff70f8f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ffb84e3497fbb58bd3c6e5803215cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a31ffb84e3497fbb58bd3c6e5803215cc">log_evaluation_mode</a> ()</td></tr>
<tr class="separator:a31ffb84e3497fbb58bd3c6e5803215cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fbac02a5f30be65d6ba7554f18e8be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#a59fbac02a5f30be65d6ba7554f18e8be">eval_precision_recall</a> (const <a class="el" href="structapp_1_1program__options.html">program_options</a> &amp;params)</td></tr>
<tr class="separator:a59fbac02a5f30be65d6ba7554f18e8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec65e0a60ef4b8340afa762ff5d4cd45"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapp.html#aec65e0a60ef4b8340afa762ff5d4cd45">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespaceapp.html#a032b65c802c303d96e4302c12567afdf">cluster_info_t</a> &amp;o)</td></tr>
<tr class="separator:aec65e0a60ef4b8340afa762ff5d4cd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Solution namespace. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="afd0360326f32265761abc08c57a112ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app::adjust_program_options </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp_1_1program__options.html">program_options</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handles wrong input and either sets it right or writes error messages. Decoupled from init_program_options for readability and the chance to init stuff in between original init and adjustment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>The proram parameters that are to be checked for correctness. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE - everything correct. FALSE - uncorrectable input. </dd></dl>

</div>
</div>
<a class="anchor" id="ab95da69cbba3f625c28cb5d0d3f5ec73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double app::angle_diff </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the smallest signed distance between two angles. The result will lie within ]-180;180]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>1 An angle. </td></tr>
    <tr><td class="paramname">angle</td><td>2 An angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest signed distance between the two angles. </dd></dl>

</div>
</div>
<a class="anchor" id="a98de1bb3c1d7269c714e0e9b09490574"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceapp.html#ae4ca45a6a9a4da2d3683eac6e49bafa9">Vec1UInt</a> app::assign_membership </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceapp.html#aa7bd809a7a3b796566ed6023b105e46d">Mat1r</a> &amp;&#160;</td>
          <td class="paramname"><em>probabilities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hard assigns membership mappings given the class-membership probabilities. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probabilities</td><td>A matrix storing the probabilities of each datum to belong to one class. The probability for feature f to belong to class c must be stored in probabilities( f, c ) with the row index specifying the feature and the column index specifying the class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length of all probabilities, e.g. the number of all data points. The vector contains numbers each index to the assigned class id. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fd1d8cc33696148cdc5782472288107"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cv::Point_&lt;R&gt; app::center </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; cv::Point_&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the center of a vector of points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector of points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The center Point, which is exactly in the middle square spanned by the leftmost, uppermost, rightmost, lowermost points. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b21c7e02a9fd6bdbb694d9f78581e94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void app::check_validity </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given value is infinite or not a number. If true, an error message will be logged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The value to check. </td></tr>
    <tr><td class="paramname">alias</td><td>The values plain text alias e.g. its human understandable variable name. </td></tr>
    <tr><td class="paramname">file</td><td>The name of the file in which the check was to be found. </td></tr>
    <tr><td class="paramname">line</td><td>The line number which invoked the validity check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the number is valid, FALSE if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a540822ab461eed15893a9c71ed1b9352"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;R&gt; app::circular_cross_correlation_series </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the normalized circular delayed cross correlatipon series of two given vectors. The function calculates means and deviations under the hood, so maybe, if you have these values beforehand you should rather calculate your own correlation series inline. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first vector. </td></tr>
    <tr><td class="paramname">b</td><td>The second vector. Must have the same length as vector a. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross correlation series for both vectors with the index defining the delay. Since cross_correllation(vector, delay) = cross_correllation(vector, vector.size-delay), or, in other words, the cross correlation series is symmetric to delay = vector.size()/2, The resulting vector will be half the size of the input vectors. The vector elements are within [-1;1]. </dd></dl>

</div>
</div>
<a class="anchor" id="a57ad8be76358e3eb86c1ef52cf961213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceapp_1_1clusterer__type.html#a9d3883709cb4732512195c6ed005bc91">clusterer_type::clusterer_type</a> app::clusterer_type_from_string </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a <a class="el" href="namespaceapp_1_1clusterer__type.html" title="Possible clusterer types wrapping namespace. ">clusterer_type</a> from a given string. The check with the given string is not case sensitive. Logs an error message if the string is not a supported <a class="el" href="namespaceapp_1_1clusterer__type.html" title="Possible clusterer types wrapping namespace. ">clusterer_type</a>. type A string containing a <a class="el" href="namespaceapp_1_1clusterer__type.html" title="Possible clusterer types wrapping namespace. ">clusterer_type</a> member as a written string. </p><dl class="section return"><dt>Returns</dt><dd>A clusterer type, especially ERROR_TYPE if the given string is not supported. </dd></dl>

</div>
</div>
<a class="anchor" id="a78d284e9cd54eda48d8b3e769c5d0f17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string app::clusterer_types_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates a string with the names of the supported clusterer types. </p><dl class="section return"><dt>Returns</dt><dd>a string with the supported clusterer types. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f52b3408f946f2a5c42f45f7b62256d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app::create_directories </td>
          <td>(</td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a directory and, if necessary, the higher level directories. Logs an error message in case of error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The path of the directory to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success, FALSE in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="ac93c0f0c765a05b18846a72d3364bc7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool app::delete_file_contents </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::string &amp;)&gt;&#160;</td>
          <td class="paramname"><em>error_callback</em> = <code><a class="el" href="namespaceapp.html#ab2769ea9a48be6aaa6b5233f5a8d2af6">on_delete_file_contents_error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function that deletes the contents of a specified file and includes error handling. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>the path to the file which contents are to be erased. </td></tr>
    <tr><td class="paramname">error_callback</td><td>The function that is to be called when opening the file with ios::out | ios::trunc yields a badbit on the stream. It takes a string as an argument which will be set to the original given filename. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success, FALSE in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="a4964871026470eaf16e3f91ef43bb08d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceapp_1_1detector__type.html#ac35b8ea91b19cc3c40be2c20f7d0bfce">detector_type::detector_type</a> app::detector_type_from_string </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a <a class="el" href="namespaceapp_1_1detector__type.html" title="Possible feature extractor types wrapping namespace. ">detector_type</a> from a given string. The check with the given string is not case sensitive. Logs an error message if the string is not a supported <a class="el" href="namespaceapp_1_1detector__type.html" title="Possible feature extractor types wrapping namespace. ">detector_type</a>. type A string containing a <a class="el" href="namespaceapp_1_1detector__type.html" title="Possible feature extractor types wrapping namespace. ">detector_type</a> member as a written string. </p><dl class="section return"><dt>Returns</dt><dd>A salient region detector type, especially ERROR_TYPE if the given string is not supported. </dd></dl>

</div>
</div>
<a class="anchor" id="af478427ee0a08e8a59c872c1dee8e0c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string app::detector_types_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates a string with the names of the supported salient region detector types. </p><dl class="section return"><dt>Returns</dt><dd>a string with the supported salient regoin detector types. </dd></dl>

</div>
</div>
<a class="anchor" id="a80972fc94aa415b0a860cdcafd65367e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app::eval_bayes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapp_1_1program__options.html">program_options</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs the bayesian inference test. May log errors and even end the application in case of severe error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>The program options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a59fbac02a5f30be65d6ba7554f18e8be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app::eval_precision_recall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapp_1_1program__options.html">program_options</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs the precision/recall test. May log errors and even end the application in case of severe error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>The program options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb41bcb728aae7f4d5d564d0ac4b5332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceapp_1_1evaluation__mode.html#a36fbac5d5f1bb29ef6d5e31b898ff0c4">evaluation_mode::evaluation_mode</a> app::evaluation_mode_from_string </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a <a class="el" href="namespaceapp_1_1evaluation__mode.html" title="Possible evaluation modes wrapping namespace. ">evaluation_mode</a> from a given string. The check with the given string is not case sensitive. Logs an error message if the string is not a supported <a class="el" href="namespaceapp_1_1evaluation__mode.html" title="Possible evaluation modes wrapping namespace. ">evaluation_mode</a>. type A string containing a <a class="el" href="namespaceapp_1_1evaluation__mode.html" title="Possible evaluation modes wrapping namespace. ">evaluation_mode</a> member as a written string. </p><dl class="section return"><dt>Returns</dt><dd>An evaluation mode, especially ERROR_MODE if the given string is not supported. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bcdec6e88d26cddff18231ff70f8f05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string app::evaluation_modes_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates a string with the names of the supported evaluation mode. </p><dl class="section return"><dt>Returns</dt><dd>a string with the supported evaluation modes. </dd></dl>

</div>
</div>
<a class="anchor" id="aea2c3881de7b652e1c91e3e8d5bef365"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void app::exit_if_false </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>on_exit_result</em> = <code>RETURN_CODE::UNDEFINED_ERROR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does nothing when the specified value is true, otherwise calls the EXIT macro. Convenience method. Use in conjunction with mission critical functions that return boolean values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>If TRUE, nothing happens, if FALSE, EXIT macro will be called. </td></tr>
    <tr><td class="paramname">on_exit_result</td><td>The value that will be returned with the EXIT macro. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac752c6012ea92ef9cbc85c40a08624e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceapp_1_1extractor__type.html#af7300cd9b95601f160223029cde889cf">extractor_type::extractor_type</a> app::extractor_from_string </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a <a class="el" href="namespaceapp_1_1extractor__type.html" title="extractor_type enumeration wrapping namespace. ">extractor_type</a> from a given string. The check with the given string is not case sensitive. Logs an error message if the string is not a supported <a class="el" href="namespaceapp_1_1extractor__type.html" title="extractor_type enumeration wrapping namespace. ">extractor_type</a>. type A string containing a <a class="el" href="namespaceapp_1_1extractor__type.html" title="extractor_type enumeration wrapping namespace. ">extractor_type</a> member as a written string. </p><dl class="section return"><dt>Returns</dt><dd>A feature extractor type, especially ERROR_TYPE if the given string is not supported. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7f4b75fa49d2c76dd33d1e84bbf7b54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string app::extractor_types_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a string with the names of the supported feature extractor types. </p>
<dl class="section return"><dt>Returns</dt><dd>a string with the supported feature extractor types. </dd></dl>

</div>
</div>
<a class="anchor" id="a5578e1cb32a5b7d2240ee0fa364a983b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app::for_each_file_in_direcory_tree </td>
          <td>(</td>
          <td class="paramtype">boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(boost::filesystem::directory_entry &amp;, <a class="el" href="namespaceapp.html#a983f01fad4505cd5a1cb15e09124f47f">uint</a> level)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(boost::filesystem::filesystem_error &amp;)&gt;&#160;</td>
          <td class="paramname"><em>exception_callback</em> = <code><a class="el" href="namespaceapp.html#abc2c8a6555524e3288729a357ed1dd54">on_filesystem_exception</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_level</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a callback for every directory entry in a directory tree. Also performs exception handling. If a filesystem_exception occurs, it will be caught and the iteration will be aborted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The root directory path in which to start the iteration. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback to perform on every directory entry. It takes a boost::filesystem::directory_entry as an argument, also an unsigned int that will provide the iteration level and returns a bool. When the return value is FALSE, the whole iteration will be aborted and the function returns false. </td></tr>
    <tr><td class="paramname">exception_callback</td><td>The function that is called when an exception occurs. Takes a boost::filesystem::filesystem_error as an argument. </td></tr>
    <tr><td class="paramname">max_level</td><td>The maximum level to iterate into the directory tree starting where 0 is the base level. If max_level is set to -1, the function iterates into every file-tree depth. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of complete success. FALSE in case of an exception of kind boost::filesystem::filesystem_error. </dd></dl>

</div>
</div>
<a class="anchor" id="abff2e6a4f8dbb21e5967bd4a9d1902aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class T, class=std::allocator&lt; T &gt; &gt; class container_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool app::from_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container_type&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::string &amp;)&gt;&#160;</td>
          <td class="paramname"><em>error_open_callback</em> = <code><a class="el" href="namespaceapp.html#ad7586a2410527f8d7c03d51f23f2ccd4">on_open_file_error</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::string &amp;, unsigned int)&gt;&#160;</td>
          <td class="paramname"><em>error_read_callback</em> = <code><a class="el" href="namespaceapp.html#a3bdd1fc00a81bb4f09df8d3c3424ef91">on_read_file_error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function that appends the given stl compliant container of type string with the lines found in the given file. In error case it calls the given callbacks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">fname</td><td>The path to the file to be read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_container</td><td>The stl compliant container of in which the read found lines shall be written. The container must support push_back(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">error_open_callback</td><td>The function that is to be called when the file could not be openend. It takes a string as an argument which will be set to the original given filename. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">error_read_callback</td><td>The function that is called when there occured an error while reading the file. It takes a string as an argument which will be set to the original given filename. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success, FALSE in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d7b31e6b48e4bf41193cfa350c1fca5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , template&lt; class T, class=std::allocator&lt; T &gt; &gt; class container_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool app::from_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container_type&lt; F &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::string &amp;)&gt;&#160;</td>
          <td class="paramname"><em>error_open_callback</em> = <code><a class="el" href="namespaceapp.html#ad7586a2410527f8d7c03d51f23f2ccd4">on_open_file_error</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::string &amp;, unsigned int)&gt;&#160;</td>
          <td class="paramname"><em>error_read_callback</em> = <code><a class="el" href="namespaceapp.html#a3bdd1fc00a81bb4f09df8d3c3424ef91">on_read_file_error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function that appends the given stl compliant container with the elements found in the lines of the given file. In error case it calls the given callbacks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">fname</td><td>The path to the file to be read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_container</td><td>The stl compliant container of in which the read found lines shall be written. The container must support push_back(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">error_open_callback</td><td>The function that is to be called when the file could not be openend. It takes a string as an argument which will be set to the original given filename. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">error_read_callback</td><td>The function that is called when there occured an error while reading the file. It takes a string as an argument which will be set to the original given filename and an unsigned int that represents the error-provoking line in the file (0-based indexing). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success, FALSE in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="a841ba5877e0efc1a2918f24e5acb3479"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool app::from_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat_&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::string &amp;, const int line) &gt;&#160;</td>
          <td class="paramname"><em>error_invalid_mat_callback</em> = <code><a class="el" href="namespaceapp.html#acc4031cbaf44adbc539d4825c261ca02">on_invalid_mat</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads a (one-dimensional) plain matrix from a file. For more complex data formats consider cv::FileStorage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">fname</td><td>The path to the file where the matrix is stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_mat</td><td>A reference to the matrix that shall store the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success. FALSE, if there occured any file i/o related error. </dd></dl>

</div>
</div>
<a class="anchor" id="a3613a674a30654439fd46e39d4a8f22e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , template&lt; class T, class=std::allocator&lt; T &gt; &gt; class container_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">container_type&lt;F&gt; app::from_stream </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in_stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>from_stream for stl containers. Puts all elements of the in_stream into a return container. Containers should implement push_back in order to work correctly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_stream</td><td>The container in an istream form, spaces are supposed to be the delimeters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A container consisting of the elements found in the stream. </dd></dl>

</div>
</div>
<a class="anchor" id="aa022e64add8ebff29719e167ce24bd7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , template&lt; class T, class=std::allocator&lt; T &gt; &gt; class container_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">container_type&lt;F&gt; app::from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Puts all numbers in a given string into an stl container. The container type must be able to perform push_back(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string that is to be converted into a container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An stl container of a given numerical type. </dd></dl>

</div>
</div>
<a class="anchor" id="a2da989da51dae7767fa1bf82172a2e36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceapp_1_1input__request.html#aea4d1c47249b0959e3ff44c3b60cc7df">input_request::input_request</a> app::get_keyboard_input </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Handles buffered keyboard input after the processing chain finished working. XXX may be unsafe in some situations. </p><dl class="section return"><dt>Returns</dt><dd>Returns an input request to the caller. </dd></dl>

</div>
</div>
<a class="anchor" id="a69e2a618f7561a4909b1afdfd2e763ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string app::get_mat_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the string giving the Matrix type of an opencv matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>The numerical matrix type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the given matrix type. </dd></dl>

</div>
</div>
<a class="anchor" id="ac41fd06c840b462a7867f27836b3e47c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app::getlines_from_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::string &amp;, unsigned int)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::string &amp;)&gt;&#160;</td>
          <td class="paramname"><em>error_open_callback</em> = <code><a class="el" href="namespaceapp.html#ad7586a2410527f8d7c03d51f23f2ccd4">on_open_file_error</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::string &amp;, unsigned int)&gt;&#160;</td>
          <td class="paramname"><em>error_read_callback</em> = <code><a class="el" href="namespaceapp.html#a3bdd1fc00a81bb4f09df8d3c3424ef91">on_read_file_error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function that reads and processes every line in a file. It opens the file, reads, and processes every line via a specified callback and then closes the file. It does proper opening and error handling with help of the specified callback functions for the two error cases. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The path of the file to be read. </td></tr>
    <tr><td class="paramname">callback</td><td>The function that is to be called for every line. It takes a string as an argument which will be set to the line read and an unsigned integer that reveals the current line number (0-based indexing) to the callback. </td></tr>
    <tr><td class="paramname">error_open_callback</td><td>The function that is to be called when the file could not be openend. It takes a string as an argument which will be set to the original given filename. </td></tr>
    <tr><td class="paramname">error_read_callback</td><td>The function that is called when there occured an error while reading the file. It takes a string as an argument which will be set to the original given filename. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success, FALSE in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="a41c57a163d1c2e36e9ecb9f5e42ac5b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app::init_program_options </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapp_1_1program__options.html">program_options</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the program options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">argc</td><td>The argument counter (e.g. coming from the main function). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">argv</td><td>The argument vector array (e.g. coming from the main function). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>The program parameters that are to be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns TRUE in case of success, returns FALSE in case of failure.</dd></dl>
<p>Initializes the program options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>The argument counter (e.g. coming from the main function). </td></tr>
    <tr><td class="paramname">argv</td><td>The argument vector array (e.g. coming from the main function). </td></tr>
    <tr><td class="paramname">p</td><td>The program parameters that are to be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns TRUE in case of success, returns FALSE in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a337440dd24613eeebf2395351e1e6bbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app::is_image_filetype_supported </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>extension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a given file extension (with point) is supported by the application. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extension</td><td>A file extension with leading point, e.g. ".jpg". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE - if image filetype is supported. FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a62caaad5d84f1cbd2f91c8134e26b162"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool app::is_inf </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if a given number is bigger than the type boundaries, e.g. if a number is infinite.. With C++11 consider using std::isinf. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The value to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE, if the number is infinite, FALSE if the given value is not. </dd></dl>

</div>
</div>
<a class="anchor" id="a69ca251579d3eaef879a0fa98ec363e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool app::is_nan </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether a given number not a number. With C++11 consider using std::isnan. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The value to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE, if the number is NaN, FALSE if the given value is not. </dd></dl>

</div>
</div>
<a class="anchor" id="ad572389c14e2c9526f91ae8131459322"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool app::is_valid </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks wethers a given number is a valid number, e.g. is finite and is not NaN. With C++11 consider using std::isnan and std::isinf. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The value to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the given value is a valid number, FALSE if it is not. </dd></dl>

</div>
</div>
<a class="anchor" id="a939e1a71674bdad3743a4b4da97d4acc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapp_1_1global__stats.html">global_stats</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Logs the given global stats. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stats</td><td>The statistics to be logged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1606407671f1d1f26e7fadd644ffbdfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void app::log_clusterer_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Logs the clusterer types for information purposes. </p>

</div>
</div>
<a class="anchor" id="a91547e5cba73d45c1e1ed7489d8563d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void app::log_detector_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Logs the salient region detector types for information purposes. </p>

</div>
</div>
<a class="anchor" id="a31ffb84e3497fbb58bd3c6e5803215cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void app::log_evaluation_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Logs the evaluation modes for information purposes. </p>

</div>
</div>
<a class="anchor" id="a1012f9b751c47c096f29a62a55a5ef8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app::log_keyboard_commands </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Logs the keyboard commands for information purposes. </p>

</div>
</div>
<a class="anchor" id="a6f6fdddafe8b628f1c7ffa1adbb07baa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app::log_program_options </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapp_1_1program__options.html">program_options</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Logs the given program parameters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <a class="el" href="structapp_1_1program__options.html" title="Hold global program configurations. Holds the global program attributes and the descriptions of the a...">program_options</a> to be logged.</td></tr>
  </table>
  </dd>
</dl>
<p>Logs the given program parameters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The <a class="el" href="structapp_1_1program__options.html" title="Hold global program configurations. Holds the global program attributes and the descriptions of the a...">program_options</a> to be logged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85261fc6195c35ee47c4c5d835b11c29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int app::nb_getch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>convenience function for non-blocking getch(). </p><dl class="section return"><dt>Returns</dt><dd>The value that would be returned by getch(). </dd></dl>

</div>
</div>
<a class="anchor" id="ab2769ea9a48be6aaa6b5233f5a8d2af6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void app::on_delete_file_contents_error </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read line error callback function originally for <a class="el" href="namespaceapp.html#ac93c0f0c765a05b18846a72d3364bc7e">delete_file_contents()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceapp.html#ac93c0f0c765a05b18846a72d3364bc7e">delete_file_contents()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abc2c8a6555524e3288729a357ed1dd54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app::on_filesystem_exception </td>
          <td>(</td>
          <td class="paramtype">boost::filesystem::filesystem_error &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>filesystem_error exception callback function originally for <a class="el" href="namespaceapp.html#a5578e1cb32a5b7d2240ee0fa364a983b">for_each_file_in_direcory_tree()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceapp.html#a5578e1cb32a5b7d2240ee0fa364a983b">for_each_file_in_direcory_tree()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acc4031cbaf44adbc539d4825c261ca02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void app::on_invalid_mat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>invalid matrix callback function originally for <a class="el" href="namespaceapp.html#abff2e6a4f8dbb21e5967bd4a9d1902aa">from_file()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The matrix filename. </td></tr>
    <tr><td class="paramname">line</td><td>The line number where the error was created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceapp.html#abff2e6a4f8dbb21e5967bd4a9d1902aa">from_file()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad7586a2410527f8d7c03d51f23f2ccd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void app::on_open_file_error </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open file error callback function originally for <a class="el" href="namespaceapp.html#ac41fd06c840b462a7867f27836b3e47c">getlines_from_file()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceapp.html#ac41fd06c840b462a7867f27836b3e47c">getlines_from_file()</a> </dd>
<dd>
<a class="el" href="namespaceapp.html#a159b1b383e66f23254b88ece2f9b97e0">to_file()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3bdd1fc00a81bb4f09df8d3c3424ef91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void app::on_read_file_error </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open file error callback function originally for <a class="el" href="namespaceapp.html#ac41fd06c840b462a7867f27836b3e47c">getlines_from_file()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceapp.html#ac41fd06c840b462a7867f27836b3e47c">getlines_from_file()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8e8b1690715c26806eaad3acc95652d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void app::on_write_file_error </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write error callback function originally for <a class="el" href="namespaceapp.html#a159b1b383e66f23254b88ece2f9b97e0">to_file()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceapp.html#a159b1b383e66f23254b88ece2f9b97e0">to_file()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aec65e0a60ef4b8340afa762ff5d4cd45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; app::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceapp.html#a032b65c802c303d96e4302c12567afdf">cluster_info_t</a> &amp;&#160;</td>
          <td class="paramname"><em>ci</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stream out operator for cluster_info_t objects used by the precision/recall tests. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td>A stream that will be modified. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ci</td><td>The cluster_info_t object that is to be written to the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the exact given stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a58c7014015b1485993355cb2d15a4bc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; app::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stream out operator on vectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>An ostream. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>a std::vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ostream that was the first parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="a76a78a30cf43e30263e71a29fddd7867"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int app::parent </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; cv::Vec4i &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>contour_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A convenience function for better readability of code. equals to hierarchy[contour_index][3]; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hierarchy</td><td>A hierarchy of contours. </td></tr>
    <tr><td class="paramname">contour_index</td><td>The index of a contour. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the parent contour, -1 if there is no parent-contour. </dd></dl>

</div>
</div>
<a class="anchor" id="a276268e81e87e71f189fac56c0d6703b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app::print_help_message </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a help message consisting of all given opptions_description pointers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The number of given options_description pointers. </td></tr>
    <tr><td class="paramname">...</td><td>an arbitrary number of options_description pointers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43eac5f357b8c07e316ac173d6ed99ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app::remove_path </td>
          <td>(</td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a path (folder or file) ultimately from the filesystem. Logs error messages in case of some error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A path to a file or a folder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success, FALSE in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e4212642aa23497c58e13d8c4fe8d7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; app::resize_interpolated </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceapp.html#a983f01fad4505cd5a1cb15e09124f47f">uint</a>&#160;</td>
          <td class="paramname"><em>new_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resizes a vector and linearly interpolates the vector elements when upscaling/downscaling. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector of type T that is to be resized. Type T must understand operations like addition T+T and multiplication with a floating point value. </td></tr>
    <tr><td class="paramname">new_size</td><td>The size of the new output vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An resized, linearly interpolated version of the given vector with the given new length. </dd></dl>

</div>
</div>
<a class="anchor" id="a3516395d9bd8945f4bc7f44bc22bce26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app::symlink </td>
          <td>(</td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>original_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>symlink_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Symlinks a file using boost::filesystem::create_symlink. If an exception is thrown, it will be caught and handled. On Windows 7, this needs elevated rights for your program, check it out on your system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original_path</td><td>The path of the original file. </td></tr>
    <tr><td class="paramname">symlink_path</td><td>The path of the symlink to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success, FALSE in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="a159b1b383e66f23254b88ece2f9b97e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , template&lt; class T, class=std::allocator&lt; T &gt; &gt; class container_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool app::to_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container_type&lt; F &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delimeter</em> = <code>&quot;\n&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::string &amp;) &gt;&#160;</td>
          <td class="paramname"><em>error_open_callback</em> = <code><a class="el" href="namespaceapp.html#ad7586a2410527f8d7c03d51f23f2ccd4">on_open_file_error</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::string &amp;) &gt;&#160;</td>
          <td class="paramname"><em>error_write_callback</em> = <code><a class="el" href="namespaceapp.html#a8e8b1690715c26806eaad3acc95652d7">on_write_file_error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function that writes the contents of a container to a specified file. Truncates all old entries in that given file. Also does error handling via callbacks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The name of the file to be written to. </td></tr>
    <tr><td class="paramname">container</td><td>The stl-compliant container to be written to file. </td></tr>
    <tr><td class="paramname">delimeter</td><td>The delimeter between each entry in the container. </td></tr>
    <tr><td class="paramname">error_open_callback</td><td>The function that is called when opening the file fails. It takes a string (the filename) as an argument. </td></tr>
    <tr><td class="paramname">error_write_callback</td><td>The function that is called when writing to the file fails. It takes a string (the filename) as an argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success, FALSE in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="a8762b23bd248bc58b2a9a0c6c6bc5238"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool app::to_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat_type &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>row_delimeter</em> = <code>&quot;\n&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>col_delimeter</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::string &amp;) &gt;&#160;</td>
          <td class="paramname"><em>error_open_callback</em> = <code><a class="el" href="namespaceapp.html#ad7586a2410527f8d7c03d51f23f2ccd4">on_open_file_error</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::string &amp;) &gt;&#160;</td>
          <td class="paramname"><em>error_write_callback</em> = <code><a class="el" href="namespaceapp.html#a8e8b1690715c26806eaad3acc95652d7">on_write_file_error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function that writes the contents of a Mat_ to a specified file. It writes the plain matrix to the file. For more complex data formats consider cv::FileStorage. Truncates all old entries in that given file. Also does error handling via callbacks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The name of the file to be written to. </td></tr>
    <tr><td class="paramname">mat</td><td>The Mat_ that is to be written to file. </td></tr>
    <tr><td class="paramname">row_delimeter</td><td>The delimeter between each row in in the matrix. </td></tr>
    <tr><td class="paramname">col_delimeter</td><td>The delimeter between each column in in the matrix. </td></tr>
    <tr><td class="paramname">error_open_callback</td><td>The function that is called when opening the file fails. It takes a string (the filename) as an argument. </td></tr>
    <tr><td class="paramname">error_write_callback</td><td>The function that is called when writing to the file fails. It takes a string (the filename) as an argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success, FALSE in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="a6900ebadff0147fabc161a10e16d2de2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; app::to_lower </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts all capital letters in a to lower case. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input string for the sake of inline usage. </dd></dl>

</div>
</div>
<a class="anchor" id="ada5b2fbaa6faa41b0dffa39f410f002c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string app::to_lower </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the given string in a new lower case string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input string for the sake of inline usage. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0b7e46dce9eccf90ca714b444221c13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , template&lt; class T, class=std::allocator&lt; T &gt; &gt; class container_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string app::to_string </td>
          <td>(</td>
          <td class="paramtype">container_type&lt; F &gt;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delimeter</em> = <code>&quot;;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>to-string for stl containers like vectors and stacks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>container to be converted to a string. </td></tr>
    <tr><td class="paramname">The</td><td>delimeter of the list elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string consisting of the elements of the container. </dd></dl>

</div>
</div>
<a class="anchor" id="a55324dccec02bb8125981faaf8ea479a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double app::wrap </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upper_limit</em> = <code>360</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>wraps the value of val into the range [0;upper_limit]. You could use it for e.g. wrapping degrees like 721 to a [0;360] range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to be wrapped. </td></tr>
    <tr><td class="paramname">upper_limit</td><td>The upper limit to which to wrap. Values bigger than upper_limit will be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The wrapped value. </dd></dl>

</div>
</div>
<a class="anchor" id="afec26344c595ee9dcffc24abf83e5b7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string app::yes_no </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gives a bool into a "yes"/"no" string representation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>A boolean value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the input parameter. true - returns "yes" false - returns "no" </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceapp.html">app</a></li>
    <li class="footer">Generated on Fri Jul 17 2015 13:28:01 for Unsupervised Detection of Salient Region in Image Databases by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
